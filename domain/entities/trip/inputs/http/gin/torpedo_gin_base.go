// Code generated by TORPEDO DO NOT EDIT.

// Package gin input
package gin

import (
	"errors"
	"fmt"
	"github.com/darksubmarine/booking-fly/domain/entities/trip"
	"github.com/darksubmarine/torpedo-lib-go"
	"github.com/darksubmarine/torpedo-lib-go/api"
	"github.com/darksubmarine/torpedo-lib-go/entity"
	"github.com/darksubmarine/torpedo-lib-go/http/gin_utils"
	"github.com/darksubmarine/torpedo-lib-go/log"
	"github.com/darksubmarine/torpedo-lib-go/object"
	"github.com/darksubmarine/torpedo-lib-go/tql"
	"github.com/gin-gonic/gin"
	"net/http"

	"github.com/darksubmarine/torpedo-lib-go/ptr"

	"strconv"
)

// inputGinBase struct to bind Gin Framework with the service CRUD operations
type inputGinBase struct {
	srv    trip.IService
	logger log.ILogger
}

// newInputGinBase constructor function
func newInputGinBase(service trip.IService, logger log.ILogger) *inputGinBase {
	return &inputGinBase{srv: service, logger: logger}
}

// register adds endpoints to Gin Router.
//
// CRUD endpoints:
//   - Create: [POST]   /trips
//   - Read:   [GET]    /trips/:id
//   - Update: [PUT]    /trips/:id
//   - Delete: [DELETE] /trips/:id
//
// Torpedo reserved endpoints:
//   - TQL: [POST] /trips/query (Torpedo Query Language: https://darksubmarine.com/docs/torpedo/tql.html)
func (h *inputGinBase) register(g gin.IRouter, withMiddlewares ...*gin_utils.TorpedoMiddleware) {

	var middlewares *gin_utils.CRUDQMiddleware
	if len(withMiddlewares) > 0 {
		middlewares = gin_utils.ToCRUDQMiddlewares(withMiddlewares...)
	}

	if middlewares == nil {

		g.POST("/trips/query", h.TQL) // used for TQL

		g.POST("/trips", h.Create)
		g.GET("/trips/:id", h.Read)
		g.PUT("/trips/:id", h.Update)
		g.DELETE("/trips/:id", h.Delete)

		//Relationship endpoints

		g.GET("/users/:id/trips", h.FetchByUser)
		g.POST("/users/:id/trips", h.CreateByUser)
		g.PUT("/users/:id/trips/:tripId", h.UpdateByUser)
		g.DELETE("/users/:id/trips/:tripId", h.DeleteByUser)
		g.DELETE("/users/:id/trips", h.DeleteAllByUser)

		return
	}

	if middlewares.HasQuery() {
		g.POST("/trips/query", append(middlewares.Query, h.TQL)...)
	} else {
		g.POST("/trips/query", h.TQL)
	}

	if middlewares.HasCreate() {
		g.POST("/trips", append(middlewares.Create, h.Create)...)

		g.POST("/users/:id/trips", append(middlewares.Create, h.CreateByUser)...)

	} else {
		g.POST("/trips", h.Create)

		g.POST("/users/:id/trips", h.CreateByUser)

	}

	if middlewares.HasRead() {
		g.GET("/trips/:id", append(middlewares.Read, h.Read)...)

		g.GET("/users/:id/trips", append(middlewares.Read, h.FetchByUser)...)

	} else {
		g.GET("/trips/:id", h.Read)

		g.GET("/users/:id/trips", h.FetchByUser)

	}

	if middlewares.HasUpdate() {
		g.PUT("/trips/:id", append(middlewares.Update, h.Update)...)

		g.PUT("/users/:id/trips/:tripId", append(middlewares.Update, h.UpdateByUser)...)

	} else {
		g.PUT("/trips/:id", h.Update)

		g.PUT("/users/:id/trips/:tripId", h.UpdateByUser)

	}

	if middlewares.HasDelete() {
		g.DELETE("/trips/:id", append(middlewares.Delete, h.Delete)...)

		g.DELETE("/users/:id/trips/:tripId", append(middlewares.Delete, h.DeleteByUser)...)
		g.DELETE("/users/:id/trips", append(middlewares.Delete, h.DeleteAllByUser)...)

	} else {
		g.DELETE("/trips/:id", h.Delete)

		g.DELETE("/users/:id/trips/:tripId", h.DeleteByUser)
		g.DELETE("/users/:id/trips", h.DeleteAllByUser)

	}
}

// TQL Torpedo Query Language input controller that calls the service Query method
func (h *inputGinBase) TQL(c *gin.Context) {
	var query tql.Query
	if err := c.ShouldBindJSON(&query); err != nil {
		c.JSON(http.StatusBadRequest, api.ErrorBindingJSON(err))
		return
	}

	if list, err := h.srv.Query(&query); err != nil {
		if errors.Is(err, tql.ErrInvalidFieldName) || errors.Is(err, tql.ErrInvalidSortFieldNotProjectionMember) {
			c.JSON(http.StatusBadRequest, api.ErrorEntityQueryByUser(err))
		} else {
			c.JSON(http.StatusInternalServerError, api.ErrorEntityQuery(err))
		}
		return
	} else {
		c.JSON(http.StatusOK, list)
	}
}

// Create input controller that calls the service create function
// @Summary create a trip
// @Schemes http https
// @Description creates an entity TripEntity
// @Tags trips
// @Accept json
// @Produce json
// @Param trip body PartialDTO true "The user fly trip reservations"
// @Success 200 {object} FullDTO
// @Failure 400 {object} api.Error
// @Failure 500 {object} api.Error
// @Router /trips [post]
func (h *inputGinBase) Create(c *gin.Context) {
	var pdto PartialDTO
	if err := c.ShouldBindJSON(&pdto); err != nil {
		c.JSON(http.StatusBadRequest, api.NewError("4001", err))
		return
	}

	h.create(pdto, c)
}

// Update input controller that calls the service update function
// @Summary update a trip
// @Schemes http https
// @Description updates an entity TripEntity
// @Tags trips
// @Accept json
// @Produce json
// @Param id path string true "trip Id"
// @Param trip body UpdatableDTO true "The user fly trip reservations"
// @Success 200 {object} FullDTO
// @Failure 400 {object} api.Error
// @Failure 500 {object} api.Error
// @Router /trips/{id} [put]
func (h *inputGinBase) Update(c *gin.Context) {
	var pdto UpdatableDTO
	if err := c.ShouldBindJSON(&pdto); err != nil {
		c.JSON(http.StatusBadRequest, api.NewError("4001", err))
		return
	}

	id := c.Param("id")
	h.update(id, pdto, c)
}

// Read input controller that calls the service read function
// @Summary get a trip
// @Schemes http https
// @Description get an entity TripEntity by Id
// @Tags trips
// @Accept json
// @Produce json
// @Param id path string true "trip Id"
// @Success 200 {object} FullDTO
// @Failure 404 {object} api.Error
// @Failure 500 {object} api.Error
// @Router /trips/{id} [get]
func (h *inputGinBase) Read(c *gin.Context) {

	ctx, _ := gin_utils.GetDataContext(c)
	id := c.Param("id")
	ety, err := h.srv.Read(ctx, id)
	if err != nil {
		if errors.Is(err, torpedo_lib.ErrIdNotFound) {
			c.JSON(http.StatusNotFound, api.NewError("4004", err))
		} else {
			c.JSON(http.StatusInternalServerError, api.NewError("5003", err))
		}
		return
	}

	if ety == nil {
		c.JSON(http.StatusNotFound, api.NewError("4004", torpedo_lib.ErrIdNotFound))
		return
	}

	if dto, err := FromEntity(ety); err != nil {
		c.JSON(http.StatusInternalServerError, api.NewError("5002", err))
	} else {
		c.JSON(http.StatusOK, dto)
	}
}

// Delete input controller that calls the service delete function
// @Summary remove a trip
// @Schemes http https
// @Description remove an entity TripEntity by Id
// @Tags trips
// @Accept json
// @Produce json
// @Param id path string true "trip Id"
// @Success 204
// @Failure 404 {object} api.Error
// @Failure 500 {object} api.Error
// @Router /trips/{id} [delete]
func (h *inputGinBase) Delete(c *gin.Context) {

	id := c.Param("id")
	h.delete(id, c)
}

// FetchByUser input controller that calls the service BelongsToUser function
// @Summary get a trip list
// @Schemes http https
// @Description get list of entity TripEntity given a userId
// @Tags trips
// @Accept json
// @Produce json
// @Param id path string true "userId"
// @Param page query int false "the pagination page number"
// @Param items query int false "the amount of items per page"
// @Success 200 {array} FullDTO
// @Failure 404 {object} api.Error
// @Failure 500 {object} api.Error
// @Router /users/{id}/trips [get]
func (h *inputGinBase) FetchByUser(c *gin.Context) {

	id := c.Param("id")
	if id == "" {
		c.JSON(http.StatusBadRequest, api.ErrorEntityQueryByUser(errors.New("user id is required")))
		return
	}

	var page int64 = 1
	if sPage := c.Query("page"); sPage != "" {
		if n, err := strconv.ParseInt(sPage, 10, 64); err == nil {
			page = n
		}
	}

	var items int64 = 50
	if sItems := c.Query("items"); sItems != "" {
		if n, err := strconv.ParseInt(sItems, 10, 64); err == nil {
			items = n
		}
	}

	lstEty, err := h.srv.BelongsToUser(id, items, page)
	if err != nil {
		c.JSON(http.StatusInternalServerError, api.ErrorEntityQuery(err))
		return
	}

	if len(lstEty) == 0 {
		c.JSON(http.StatusNotFound, api.ErrorNotFound(errors.New("no data where found with the given id")))
		return
	}

	toRet := make([]*FullDTO, len(lstEty))
	for i, ety := range lstEty {
		dto := NewFullDTO()
		if err := entity.To(ety, dto); err != nil {
			h.logger.Error("trying too convert entity to DTO", "error", err)
		}
		toRet[i] = dto
	}

	c.JSON(http.StatusOK, toRet)
}

// Create by User input controller that calls the service create function
// @Summary create a trip
// @Schemes http https
// @Description creates an entity TripEntity
// @Tags trips
// @Accept json
// @Produce json
// @Param trip body PartialDTO true "The user fly trip reservations"
// @Success 200 {object} FullDTO
// @Failure 400 {object} api.Error
// @Failure 500 {object} api.Error
// @Router /users/{id}/trips [post]
func (h *inputGinBase) CreateByUser(c *gin.Context) {
	var pdto PartialDTO
	if err := c.ShouldBindJSON(&pdto); err != nil {
		c.JSON(http.StatusBadRequest, api.NewError("4001", err))
		return
	}

	pdto.UserId_ = ptr.String(c.Param("id"))

	h.create(pdto, c)
}

// Update by User input controller that calls the service update function
// @Summary update a trip
// @Schemes http https
// @Description updates an entity TripEntity
// @Tags trips
// @Accept json
// @Produce json
// @Param trip body UpdatableDTO true "The user fly trip reservations"
// @Success 200 {object} FullDTO
// @Failure 400 {object} api.Error
// @Failure 500 {object} api.Error
// @Router /users/{id}/trips/{tripId} [put]
func (h *inputGinBase) UpdateByUser(c *gin.Context) {
	var pdto UpdatableDTO
	if err := c.ShouldBindJSON(&pdto); err != nil {
		c.JSON(http.StatusBadRequest, api.ErrorBindingJSON(err))
		return
	}

	pdto.UserId_ = ptr.String(c.Param("id"))
	id := c.Param("tripId")
	h.update(id, pdto, c)
}

// DeleteByUser input controller that calls the service delete function
// @Summary remove a trip
// @Schemes http https
// @Description remove an entity TripEntity by Id
// @Tags trips
// @Accept json
// @Produce json
// @Param id path string true "trip Id"
// @Success 204
// @Failure 404 {object} api.Error
// @Failure 500 {object} api.Error
// @Router /users/{id}/trips/{tripId} [delete]
func (h *inputGinBase) DeleteByUser(c *gin.Context) {
	id := c.Param("tripId")
	h.delete(id, c)
}

// DeleteAllByUser input controller that calls the service delete function
// @Summary remove all trip given a userId
// @Schemes http https
// @Description remove all entity TripEntity by userId
// @Tags trips
// @Accept json
// @Produce json
// @Param userId path string true "user Id"
// @Success 204
// @Failure 404 {object} api.Error
// @Failure 500 {object} api.Error
// @Router /users/{id}/trips [delete]
func (h *inputGinBase) DeleteAllByUser(c *gin.Context) {
	id := c.Param("id")
	if err := h.srv.DeleteByUser(id); err != nil {
		if errors.Is(err, torpedo_lib.ErrIdNotFound) {
			c.JSON(http.StatusNotFound, api.ErrorNotFound(err))
		} else {
			c.JSON(http.StatusInternalServerError, api.ErrorEntityRemove(err))
		}
		return
	}

	c.JSON(http.StatusNoContent, nil)
}

// --- Private methods ---
func (h *inputGinBase) create(pdto PartialDTO, c *gin.Context) {
	if ok, err := object.IsComplete(pdto, optionalFields...); !ok {
		if err != nil {
			c.JSON(http.StatusBadRequest, api.ErrorPartialEntityIncomplete(err))
		} else {
			c.JSON(http.StatusBadRequest, api.ErrorPartialEntityIncomplete(fmt.Errorf("all fields are required")))
		}
		return
	}

	ety := trip.New()
	if err := entity.From(&pdto, ety); err != nil {
		c.JSON(http.StatusBadRequest, api.ErrorBuildingEntityFromDTO(err))
		return
	} else {
		ctx, _ := gin_utils.GetDataContext(c)
		if created, err := h.srv.Create(ctx, ety); err != nil {
			c.JSON(http.StatusInternalServerError, api.ErrorEntityCreation(err))
			return
		} else {
			returnDto := NewFullDTO()
			if err := entity.To(created, returnDto); err != nil {
				c.JSON(http.StatusInternalServerError, api.ErrorEntityCreation(err)) // TODO replace the error
			}

			c.JSON(http.StatusOK, returnDto)
			return
		}
	}
}

func (h *inputGinBase) update(id string, pdto UpdatableDTO, c *gin.Context) {
	if ok, err := object.IsComplete(pdto, optionalFields...); !ok {
		if err != nil {
			c.JSON(http.StatusBadRequest, api.ErrorPartialEntityIncomplete(err))
		} else {
			c.JSON(http.StatusBadRequest, api.ErrorPartialEntityIncomplete(fmt.Errorf("all fields are required")))
		}
		return
	}

	ety := trip.New()
	if err := entity.From(&pdto, ety); err != nil {
		c.JSON(http.StatusBadRequest, api.ErrorBuildingEntityFromDTO(err))
		return
	} else {
		ety.SetId(id)
		ctx, _ := gin_utils.GetDataContext(c)
		if updated, err := h.srv.Update(ctx, ety); err != nil {
			if errors.Is(err, torpedo_lib.ErrIdNotFound) {
				c.JSON(http.StatusNotFound, api.ErrorNotFound(err))
			} else {
				c.JSON(http.StatusInternalServerError, api.ErrorEntityUpdate(err))
			}
			return
		} else {
			returnDto := NewFullDTO()
			if err := entity.To(updated, returnDto); err != nil {
				c.JSON(http.StatusInternalServerError, api.ErrorEntityUpdate(err))
			}

			c.JSON(http.StatusOK, returnDto)
			return
		}
	}
}

func (h *inputGinBase) delete(id string, c *gin.Context) {
	ctx, _ := gin_utils.GetDataContext(c)
	if err := h.srv.Delete(ctx, id); err != nil {
		if errors.Is(err, torpedo_lib.ErrIdNotFound) {
			c.JSON(http.StatusNotFound, api.ErrorNotFound(err))
		} else {
			c.JSON(http.StatusInternalServerError, api.ErrorEntityRemove(err))
		}
		return
	}

	c.JSON(http.StatusNoContent, nil)
}
